#include <iostream>

const int MAX_SIZE = 32;
/*
Для хранения двоичного представления числа использую массив символов. 
Место под которое сразу резервирую максимально возможным кол-вом потребуемых бит. 
Это и есть слабое место алгоритма - число, двоичного представление которого 
может поместиться в 10 символов строки, оставшаяся выделенная память будет проставивать.
*/

void toBinary(int value)
{
	char buffer[MAX_SIZE]; 
													
	bool negative = false; 
	int iter = 0;

	if (value < 0)
	{
		value = -value;
		negative = true;
	}

	do
	{
		buffer[iter++] = char('0' + value % 2);
		value /= 2;
	} while (value); //в buffer будет хранится двоичное представление десятичного числа
					 //в обратной последовательности!! 

	//если число отрицательное, то в начало его бинарного представления
	//добавляю знак '-'
	if (negative)
		buffer[iter++] = '-';
	iter--;

	//переворачиваю строку, т.к. начало довичного представления в конце буффера
	//(строку можно и не перевораивать, т.к. смысла в этом нет, отобразить двоичное
	//представление числа можно и итерируясь по массиву символов с конца в начало
	for (int i = 0, j = iter; i <= iter / 2; )
	{
		char temp = buffer[i];
		buffer[i++] = buffer[j];
		buffer[j--] = temp;
	}

	//идем с конца строки --> в начало, чтобы отобразить двоичное представление
	for (auto i = 0; i <= iter; i++)
		std::cout << buffer[i];
	std::cout << std::endl;

}

void task1()
{
	int number = 18;
	std::cout << "Binary representation of " << number << ": ";
	toBinary(number);

}